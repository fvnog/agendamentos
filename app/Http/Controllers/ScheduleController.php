<?php

namespace App\Http\Controllers;

use App\Models\Schedule;
use App\Models\FixedSchedule;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;

class ScheduleController extends Controller
{
    // Exibe o formul√°rio de cria√ß√£o de hor√°rios
    public function create()
    {
        return view('schedules.create');
    }

    // Armazena os hor√°rios criados
    public function store(Request $request)
    {
        Log::info("üîµ Iniciando cria√ß√£o de hor√°rios pelo usu√°rio: " . Auth::id());

        $validated = $request->validate([
            'schedule_type' => 'required|in:today,day,week,month',
            'specific_date' => 'nullable|date',
            'interval' => 'required|integer|min:5',
            'start_time' => 'required|date_format:H:i',
            'end_time' => 'required|date_format:H:i|after:start_time',
        ]);

        $user = Auth::user();
        $barberId = $user->id;
        $interval = (int) $validated['interval'];
        $start_time = Carbon::parse($request->start_time);
        $end_time = Carbon::parse($request->end_time);
        $scheduleType = $request->schedule_type;
        $specificDate = $request->specific_date;
        $dates = [];

        // üîπ Determinar as datas de cria√ß√£o conforme a op√ß√£o escolhida
        if ($scheduleType === 'today') {
            $dates[] = now()->toDateString();
        } elseif ($scheduleType === 'day' && $specificDate) {
            $dates[] = Carbon::parse($specificDate)->toDateString();
        } elseif ($scheduleType === 'week') {
            for ($i = 0; $i < 7; $i++) {
                $dates[] = now()->addDays($i)->toDateString();
            }
        } elseif ($scheduleType === 'month') {
            for ($i = 0; $i < 30; $i++) {
                $dates[] = now()->addDays($i)->toDateString();
            }
        }

        Log::info("üìÖ Datas geradas para cria√ß√£o de hor√°rios: " . json_encode($dates));

        foreach ($dates as $date) {
            $currentDate = Carbon::parse($date);
            $weekday = $currentDate->dayOfWeek;

            // üîπ Buscar clientes fixos apenas para o barbeiro atual no dia da semana correto
            $fixedSchedules = FixedSchedule::where('barber_id', $barberId)
                ->where('weekday', $weekday)
                ->orderBy('start_time')
                ->get();

            Log::info("üîé Encontrados " . $fixedSchedules->count() . " clientes fixos para o dia " . $weekday);

            // Exibir clientes fixos e seus hor√°rios no log
            $fixedClientsFound = [];
            foreach ($fixedSchedules as $fixed) {
                Log::info("üìå Cliente fixo: ID {$fixed->client_id} - Hor√°rio: {$fixed->start_time}");
                $fixedClientsFound[$fixed->client_id] = $fixed->start_time;
            }

            $currentStartTime = clone $start_time;
            $createdSchedules = []; // Lista de hor√°rios gerados

            // üîπ Criar todos os hor√°rios primeiro (sem marcar cliente fixo ainda)
            while ($currentStartTime < $end_time) {
                $formattedStartTime = $currentStartTime->format('H:i');

                $schedule = Schedule::create([
                    'user_id' => $barberId,
                    'date' => $currentDate->format('Y-m-d'),
                    'start_time' => $formattedStartTime,
                    'end_time' => $currentStartTime->copy()->addMinutes($interval)->format('H:i'),
                    'client_id' => null,  // Ainda n√£o marcamos cliente fixo
                    'is_booked' => 0,
                    'is_paid' => false,
                ]);

                Log::info("‚ûñ Criado hor√°rio livre em " . $formattedStartTime);
                $createdSchedules[$formattedStartTime] = $schedule->id; // Salva os hor√°rios criados

                $currentStartTime->addMinutes($interval);
            }

            // üîç Agora tentar associar os clientes fixos aos hor√°rios criados
            $this->marcarClientesFixos($currentDate, $barberId, $fixedClientsFound, $createdSchedules);
        }

        Log::info("‚úÖ Processo de cria√ß√£o de hor√°rios finalizado!");

        return redirect()->route('schedules.create')->with('success', 'Hor√°rios criados com sucesso!');
    }

    /**
     * Tenta associar os clientes fixos aos hor√°rios j√° criados.
     */
    private function marcarClientesFixos($date, $barberId, $fixedClientsFound, $createdSchedules)
    {
        Log::info("üîç Iniciando marca√ß√£o dos clientes fixos para a data: " . $date->format('Y-m-d'));
    
        foreach ($fixedClientsFound as $clientId => $expectedStartTime) {
            $expectedStartTimeFormatted = Carbon::parse($expectedStartTime)->format('H:i');
    
            Log::info("üìå Tentando marcar Cliente fixo ID {$clientId} para hor√°rio: {$expectedStartTimeFormatted}");
    
            // üîπ Buscar os servi√ßos do cliente fixo na tabela `fixed_schedules`
            $fixedSchedule = FixedSchedule::where('client_id', $clientId)
                ->where('barber_id', $barberId)
                ->where('weekday', $date->dayOfWeek)
                ->first();
    
            $services = [];
            $totalAmount = 0; // Inicia o total do valor dos servi√ßos
    
            if ($fixedSchedule && $fixedSchedule->services) {
                $serviceIds = json_decode($fixedSchedule->services, true);
    
                $servicesData = DB::table('services')
                    ->whereIn('id', $serviceIds)
                    ->select('id', 'name', 'price')
                    ->get();
    
                foreach ($servicesData as $service) {
                    $services[] = [
                        'id' => $service->id,
                        'name' => $service->name
                    ];
                    $totalAmount += $service->price; // Soma o valor de cada servi√ßo
                }
            }
    
            if (isset($createdSchedules[$expectedStartTimeFormatted])) {
                // üîπ Se o hor√°rio exato existir, marcar o cliente fixo
                $scheduleId = $createdSchedules[$expectedStartTimeFormatted];
    
                Schedule::where('id', $scheduleId)
                    ->update([
                        'client_id' => $clientId,
                        'is_booked' => 1,
                        'services' => json_encode($services), // ‚úÖ Salva os servi√ßos corretamente
                    ]);
    
                // üî• Inser√ß√£o do pagamento na tabela `payments`
                DB::table('payments')->insert([
                    'user_id' => $clientId,
                    'schedule_id' => $scheduleId,
                    'type' => 'pix',
                    'amount' => $totalAmount, // ‚úÖ Agora inserimos o valor correto somado
                    'txid' => 'PIX',
                    'services' => json_encode($services), // ‚úÖ Salva os servi√ßos no pagamento
                    'created_at' => now(),
                    'updated_at' => now(),
                ]);
    
                Log::info("‚úÖ Cliente fixo ID {$clientId} foi marcado no hor√°rio correto: {$expectedStartTimeFormatted} com servi√ßos: " . json_encode($services) . " e valor: R$ " . number_format($totalAmount, 2, ',', '.'));
            } else {
                // üîπ Se o hor√°rio exato n√£o existir, buscar o primeiro hor√°rio depois dispon√≠vel
                $sortedTimes = array_keys($createdSchedules);
                sort($sortedTimes);
    
                $nextAvailable = null;
                foreach ($sortedTimes as $time) {
                    if ($time >= $expectedStartTimeFormatted) {
                        $nextAvailable = $time;
                        break;
                    }
                }
    
                if ($nextAvailable) {
                    $scheduleId = $createdSchedules[$nextAvailable];
    
                    Schedule::where('id', $scheduleId)
                        ->update([
                            'client_id' => $clientId,
                            'is_booked' => 1,
                            'services' => json_encode($services), // ‚úÖ Salva os servi√ßos no hor√°rio
                        ]);
    
                    // üî• Inser√ß√£o do pagamento na tabela `payments`
                    DB::table('payments')->insert([
                        'user_id' => $clientId,
                        'schedule_id' => $scheduleId,
                        'type' => 'pix',
                        'amount' => $totalAmount, // ‚úÖ Agora inserimos o valor correto somado
                        'txid' => 'PIX',
                        'services' => json_encode($services), // ‚úÖ Salva os servi√ßos no pagamento
                        'created_at' => now(),
                        'updated_at' => now(),
                    ]);
    
                    Log::info("‚úÖ Cliente fixo ID {$clientId} foi marcado no hor√°rio dispon√≠vel mais pr√≥ximo: {$nextAvailable} com servi√ßos: " . json_encode($services) . " e valor: R$ " . number_format($totalAmount, 2, ',', '.'));
                } else {
                    Log::error("‚ùå ERRO: Cliente fixo ID {$clientId} N√ÉO foi marcado, nenhum hor√°rio dispon√≠vel.");
                }
            }
        }
    
        Log::info("üîç Marca√ß√£o dos clientes fixos conclu√≠da.");
    }


    public function getSchedules(Request $request)
    {
        $date = $request->query('date', now()->toDateString()); // Obt√©m a data selecionada ou usa a atual
        $barberId = $request->query('barber_id'); // Obt√©m o ID do barbeiro, se existir
    
        // Obt√©m apenas os usu√°rios que s√£o barbeiros (is_admin = 1)
        $barbers = User::where('is_admin', 1)->pluck('id')->toArray();
    
        // Selecione o primeiro barbeiro como padr√£o se nenhum for escolhido
        if (!$barberId) {
            $barberId = reset($barbers);
        }
    
        // Garante que o ID do barbeiro esteja na lista de barbeiros v√°lidos
        if (!in_array($barberId, $barbers)) {
            return response()->json([]);
        }
    
        // üîπ BUSCA DIRETA NO BANCO, SEM CACHE
        $schedules = Schedule::whereDate('date', $date)
                             ->where('user_id', $barberId)
                             ->get();
    
        return response()->json($schedules);
    }

    public function checkAvailability(Request $request)
{
    $schedule = Schedule::find($request->schedule_id);

    if (!$schedule) {
        return response()->json(['status' => 'error', 'message' => 'Hor√°rio n√£o encontrado.'], 404);
    }

    if ($schedule->is_booked) {
        return response()->json(['status' => 'booked', 'message' => 'Este hor√°rio j√° foi reservado.']);
    }

    if ($schedule->is_locked) {
        return response()->json(['status' => 'locked', 'message' => 'Este hor√°rio est√° sendo reservado por outro usu√°rio.']);
    }

    return response()->json(['status' => 'available']);
}

    
    
    
}
